// remove this (?): CodeMirror, copyright (c) by Marijn Haverbeke and others
// remove this (?): Distributed under an MIT license: https://codemirror.net/LICENSE

// DO NOT EDIT - AUTOGENERATED
//
// This mode has been autogenerated from the Pygments lexer [1] by the script [2].
//
// [1]: ('https://github.com/jfschaefer/glifcore',)
// [2]: https://github.com/ComFreek/mmtpygments/blob/master/mmtpygments/pygments_to_codemirror.py

function loadGlifHighlighting(CodeMirror) {
    "use strict";

    CodeMirror.defineAdvancedMode("GLIF", {
		"start": [
				{regex: /(gf:|GF:)(\s+)(\w+)/um, token: ["header", "whitespace", "variable"], transition: "gf.root"},
				{regex: /(mmt:|MMT:)(\s+)(\w+)/um, token: ["header", "whitespace", "variable"], transition: "mmt.root"},
				{regex: /(elpi:|ELPI:|elpi-notc:|ELPI-NOTC:)(\s+)(\w+)/um, token: ["header", "whitespace", "variable"], transition: "elpi.root"},
				{regex: /(abstract|resource|interface|concrete|instance)(\s+)(\w+)/um, token: ["keyword", "whitespace", "variable"], transition: "gf.root"},
				{regex: /\/T .*?❚/um, token: "comment", transition: "mmt.root"},
				{regex: /\/\/.*?❚/um, token: "comment", transition: "mmt.root"},
				{regex: /(meta)(\s+)(\S+)(\s+)([^❚]+)(\s*)(❚)/um, token: ["keyword", "whitespace", "link", "whitespace", 'MMT_ObjectExpression', "whitespace", 'MMT_MD'], transition: "mmt.root"},
				{regex: /(namespace)(\s+)(\S+?)(\s*)(❚)/um, token: ["keyword", "whitespace", "link", "whitespace", 'MMT_MD'], transition: "mmt.root"},
				{regex: /(import)(\s+)(\S+)(\s+)(\S+?)(\s*)(❚)/um, token: ["keyword", "whitespace", 'Name.Namespace', "whitespace", "link", "whitespace", 'MMT_MD'], transition: "mmt.root"},
				{regex: /(fixmeta|ref|rule)(\s+)(\S+?)(\s*)(❚)/um, token: ["comment", "whitespace", "link", "whitespace", 'MMT_MD'], transition: "mmt.root"},
				{regex: /(theory)\b/um, token: "keyword", transition: "mmt.theoryHeader"},
				{regex: /(?:(total|implicit)(\s+))?(?:(total|implicit)(\s+))?(view)\b/um, token: ["keyword", "whitespace", "keyword", "whitespace", "keyword"], transition: "mmt.viewHeader"},
				{regex: /(type|kind|accumulate|pi)/um, token: "keyword", transition: "elpi.root"},
				{regex: /(a(?:pply|rchive)|construct|e(?:g|lpigen)|filter|g(?:enerate_(?:random|trees)|[rt])|help|import|linearize|p(?:arse|ut_(?:string|tree)|[st])|query|status|v(?:isualize_(?:(?:pars|tre)e)|[pt])|[achilps])$/um, token: "keyword", transition: "cmd.root"},
				{regex: /(a(?:pply|rchive)|construct|e(?:g|lpigen)|filter|g(?:enerate_(?:random|trees)|[rt])|help|import|linearize|p(?:arse|ut_(?:string|tree)|[st])|query|status|v(?:isualize_(?:(?:pars|tre)e)|[pt])|[achilps])\b/um, token: "keyword", transition: "cmd.incommand"},
				{regex: /"([^"]|(\\"))*"$/um, token: "string", transition: "cmd.root"},
				{regex: /"([^"]|(\\"))*"/um, token: "string", transition: "cmd.incommand"},
				{regex: /\w+/um, token: 'Generic.Error', transition: "cmd.incommand"},
				{regex: /--.*$/um, token: "comment"},
				{regex: /\/\/.*$/um, token: "comment"},
				{regex: /%.*$/um, token: "comment"},
				{regex: /\/\*.*\*\//um, token: "comment"},
				{regex: /\w+/um, token: 'Generic.Error'},
		],
		"gf.root": [
				{regex: /--.*$/um, token: "comment"},
				{regex: /(\s+)/um, token: "whitespace"},
				{regex: /(abstract|resource|interface|concrete|instance)(\s+)(\w+)/um, token: ["keyword", "whitespace", "variable"]},
				{regex: /(case|in(?:(?:complete)?)|let|o(?:f|pen|verload)|pre|table|w(?:here|ith))\b/um, token: "keyword"},
				{regex: /(cat|d(?:ata|ef)|f(?:lags|un)|lin(?:(?:cat|(?:[dr])ef)?)|oper|param)\b/um, token: "header"},
				{regex: /(Int|PType|Str(?:(?:ing)?)|Type)\b/um, token: "builtin"},
				{regex: /"([^"]|(\\"))*"/um, token: "string"},
				{regex: /"(\d+)"/um, token: "number"},
				{regex: /\w+/um, token: "variable"},
		],
		"mmt.root": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /\/T .*?❚/um, token: "comment"},
				{regex: /\/\/.*?❚/um, token: "comment"},
				{regex: /(document)((?: |\t)+)(\S+?)(?=\s+)/um, token: ["keyword", "whitespace", 'Name.Namespace']},
				{regex: /(meta)(\s+)(\S+)(\s+)([^❚]+)(\s*)(❚)/um, token: ["keyword", "whitespace", "link", "whitespace", 'MMT_ObjectExpression', "whitespace", 'MMT_MD']},
				{regex: /(namespace)(\s+)(\S+?)(\s*)(❚)/um, token: ["keyword", "whitespace", "link", "whitespace", 'MMT_MD']},
				{regex: /(import)(\s+)(\S+)(\s+)(\S+?)(\s*)(❚)/um, token: ["keyword", "whitespace", 'Name.Namespace', "whitespace", "link", "whitespace", 'MMT_MD']},
				{regex: /(fixmeta|ref|rule)(\s+)(\S+?)(\s*)(❚)/um, token: ["comment", "whitespace", "link", "whitespace", 'MMT_MD']},
				{regex: /(diagram)\b/um, token: "keyword", transition: "mmt.diagramHeader"},
				{regex: /(theory)\b/um, token: "keyword", transition: "mmt.theoryHeader"},
				{regex: /(?:(total|implicit)(\s+))?(?:(total|implicit)(\s+))?(view)\b/um, token: ["keyword", "whitespace", "keyword", "whitespace", "keyword"], transition: "mmt.viewHeader"},
				{regex: /[^❚]*?❚/um, token: 'Generic.Error'},
		],
		"mmt.expectMD": [
				{regex: /(\s*)(❚)/um, token: ["whitespace", 'MMT_MD'], transition: "#pop"},
		],
		"mmt.expectDD": [
				{regex: /(\s*)(❙)/um, token: ["whitespace", 'MMT_DD'], transition: "#pop"},
		],
		"mmt.expectOD": [
				{regex: /(\s*)(❘)/um, token: ["whitespace", 'MMT_OD'], transition: "#pop"},
		],
		"mmt.structuralFeatureHeader": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /([^\s(❙❚:=]+)(\s*)(?:(\()([^)]*)(\)))?(\s*)(?:(:)(\s*)([^❘❙❚=]+))?(\s*)(?:(=)(\s*)([^\s:❙❚]+))?(\s*)(❙)/um, token: ["variable", "whitespace", "punctuation", "variable-3", "punctuation", "whitespace", "punctuation", "whitespace", "variable-3", "whitespace", "punctuation", "whitespace", "link", "whitespace", 'MMT_DD'], transition: "#pop"},
				{regex: /([^\s(❙❚:=]+)(\s*)(?:(\()([^)]*)(\)))?(\s*)(?:(:)(\s*)([^❘❙❚=]+))?(\s*)/um, token: ["variable", "whitespace", "punctuation", "variable-3", "punctuation", "whitespace", "punctuation", "whitespace", "variable-3", "whitespace"], transition: "mmt.moduleDefiniens"},
		],
		"mmt.theoryHeader": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /([^\s❙❚:=]+)(\s*)(?:(:)(\s*)([^\s❙❚=]+))?(\s*)(?:(>)([^❙❚=]+))?/um, token: ["variable", "whitespace", "punctuation", "whitespace", "link", "whitespace", "punctuation", "variable-3"], transition: "mmt.moduleDefiniens"},
		],
		"mmt.moduleDefiniens": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /❘/um, token: 'MMT_OD'},
				{regex: /#+/um, token: "punctuation", transition: "mmt.notationExpression"},
				{regex: /=/um, token: "punctuation", transition: "mmt.moduleBody"},
				{regex: /❚/um, token: 'MMT_MD', transition: "#pop:2"},
		],
		"mmt.viewHeader": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /(\S+)(\s*)(:)(\s*)(\S+)(\s*)(->|→)(\s*)([^\s❚=]+)/um, token: ["variable", "whitespace", "punctuation", "whitespace", "link", "whitespace", "punctuation", "whitespace", "link"], transition: "mmt.moduleDefiniens"},
		],
		"mmt.diagramHeader": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /(\S+)(\s*)(:)(\s*)([^❚=]+)/um, token: ["variable-3", "whitespace", "punctuation", "whitespace", "variable-3"], transition: "mmt.expression"},
				{regex: /[^❚=]+/um, token: "variable-3", transition: "mmt.expression"},
				{regex: /❚/um, token: 'MMT_MD', transition: "#pop"},
		],
		"mmt.moduleBody": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /\/T .*?(❙|❚)/um, token: "comment"},
				{regex: /\/\/.*?(❙|❚)/um, token: "comment"},
				{regex: /(@_description)(\s+)([^❙])+(❙)/um, token: ["keyword", "whitespace", "string", 'MMT_DD']},
				{regex: /(meta)(\s+)(\S+)(\s+)([^❙❚]+)(\s*)(❙)/um, token: ["keyword", "whitespace", "link", "whitespace", 'MMT_ObjectExpression', "whitespace", 'MMT_MD']},
				{regex: /(include)(\s+)([^❙]+)(❙)/um, token: ["keyword", "whitespace", "link", 'MMT_DD']},
				{regex: /(constant)(\s+)([^\s:❘❙]+)/um, token: ["keyword", "whitespace", "variable-3"], transition: "mmt.constantDeclaration"},
				{regex: /(rule)(\s+)([^❙]+)(\s*)(❙)/um, token: ["keyword", "whitespace", "link", "whitespace", 'MMT_DD']},
				{regex: /(realize)(\s+)([^❙]+)(\s*)(❙)/um, token: ["keyword", "whitespace", "link", "whitespace", 'MMT_DD']},
				{regex: /(?:(total|implicit)(\s+))?(?:(total|implicit)(\s+))?(structure\b)/um, token: ["keyword", "whitespace", "keyword", "whitespace", "keyword"], transition: "mmt.structuralFeatureHeader"},
				{regex: /theory\b/um, token: "keyword", transition: "mmt.theoryHeader"},
				{regex: /(?:(total|implicit)(\s+))?(?:(total|implicit)(\s+))?(view\b)/um, token: ["keyword", "whitespace", "keyword", "whitespace", "keyword"], transition: "mmt.viewHeader"},
				{regex: /(#+)([^❙]+)(❙)/um, token: ["string", "string", 'MMT_DD']},
				{regex: /([^\s:=#❘❙❚]+)(\s+)(?=[^\s:=@#❘❙❚]+)/um, token: ["keyword", "whitespace"], transition: "mmt.structuralFeatureHeader"},
				{regex: /[^\s:=#❘❙❚]+/um, token: "variable-3", transition: "mmt.constantDeclaration"},
				{regex: /[^❚]*?❙/um, token: 'Generic.Error'},
				{regex: /❚/um, token: 'MMT_MD', transition: "#pop:3"},
		],
		"mmt.constantDeclaration": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /:/um, token: "punctuation", transition: "mmt.expression"},
				{regex: /=/um, token: "punctuation", transition: "mmt.expression"},
				{regex: /#+/um, token: "punctuation", transition: "mmt.notationExpression"},
				{regex: /(@_description)(\s+)([^❘❙])+/um, token: ["keyword", "whitespace", "string"]},
				{regex: /(@)([^❘❙]+)/um, token: ["punctuation", "variable-2"]},
				{regex: /role\b/um, token: "keyword", transition: "mmt.expression"},
				{regex: /(meta)(\s+)(\S+)(\s+)([^❘❙]+)(\s*)(?=❘|❙)/um, token: ["keyword", "whitespace", "link", "whitespace", 'MMT_ObjectExpression', "whitespace"]},
				{regex: /\/\/[^❘❙]*/um, token: "comment"},
				{regex: /❘/um, token: 'MMT_OD'},
				{regex: /❙/um, token: 'MMT_DD', transition: "#pop"},
				{regex: /[^❙❚]*?=[^❚]*?❚/um, token: 'Generic.Error', transition: "#pop"},
				{regex: /[^❚]*?❙/um, token: 'Generic.Error', transition: "#pop"},
		],
		"mmt.notationExpression": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /\d+/um, token: "string"},
				{regex: /%?((I|V|L)\d+[Td]*)(_(I|L)\d+[Td]*)*/um, token: "string"},
				{regex: /…/um, token: "string"},
				{regex: /(\bprec)(\s+)(-?\d+)/um, token: ["keyword", "whitespace", "number"], transition: "#pop"},
				{regex: /([^\s\d…❘❙❚]+)/um, token: "string"},
				{regex: /(?=[❘❙❚])/um, token: "whitespace", transition: "#pop"},
		],
		"mmt.expression": [
				{regex: /\s+/um, token: "whitespace"},
				{regex: /[^❘❙❚]*/um, token: 'MMT_ObjectExpression', transition: "#pop"},
		],
		"elpi.root": [
				{regex: /%.*$/um, token: "comment"},
				{regex: /\/\*.*\*\//um, token: "comment"},
				{regex: /([A-Z_]\w*)/um, token: "variable-3"},
				{regex: /(_)/um, token: "variable-3"},
				{regex: /(\s+)/um, token: "whitespace"},
				{regex: /(type|kind|accumulate|pi)/um, token: "keyword"},
				{regex: /(fail|int|list|o|prop|string|type)\b/um, token: "builtin"},
				{regex: /"([^"]|(\\"))*"/um, token: "string"},
				{regex: /"(\d+)"/um, token: "number"},
				{regex: /\w+/um, token: "variable"},
		],
		"cmd.root": [
				{regex: /(--|#|\/\/|%).*$/um, token: "comment"},
				{regex: /(--|#|\/\/|%).*$/um, token: "comment"},
				{regex: /(a(?:pply|rchive)|construct|e(?:g|lpigen)|filter|g(?:enerate_(?:random|trees)|[rt])|help|import|linearize|p(?:arse|ut_(?:string|tree)|[st])|query|status|v(?:isualize_(?:(?:pars|tre)e)|[pt])|[achilps])$/um, token: "keyword", transition: "cmd.root"},
				{regex: /(a(?:pply|rchive)|construct|e(?:g|lpigen)|filter|g(?:enerate_(?:random|trees)|[rt])|help|import|linearize|p(?:arse|ut_(?:string|tree)|[st])|query|status|v(?:isualize_(?:(?:pars|tre)e)|[pt])|[achilps])\b/um, token: "keyword", transition: "cmd.incommand"},
				{regex: /"([^"]|(\\"))*"$/um, token: "string", transition: "cmd.root"},
				{regex: /"([^"]|(\\"))*"/um, token: "string", transition: "cmd.incommand"},
				{regex: /\w+/um, token: 'Generic.Error', transition: "cmd.incommand"},
		],
		"cmd.incommand": [
				{regex: /(-\w+)$/um, token: 'Name.Attribute', transition: "#pop"},
				{regex: /(-\w+)/um, token: 'Name.Attribute'},
				{regex: /(-\w+)(=)((?:\w|\d)+)$/um, token: ['Name.Attribute', "punctuation", "variable-2"], transition: "#pop"},
				{regex: /(-\w+)(=)((?:\w|\d)+)/um, token: ['Name.Attribute', "punctuation", "variable-2"]},
				{regex: /(-\w+)(=)("(?:[^"]|(?:\\"))*")$/um, token: ['Name.Attribute', "punctuation", "string"], transition: "#pop"},
				{regex: /(-\w+)(=)("(?:[^"]|(?:\\"))*")/um, token: ['Name.Attribute', "punctuation", "string"]},
				{regex: /"([^"]|(\\"))*"$/um, token: "string", transition: "#pop"},
				{regex: /"([^"]|(\\"))*"/um, token: "string"},
				{regex: /\|/um, token: "punctuation", transition: "#pop"},
				{regex: /[ \t]*$/um, token: "whitespace", transition: "#pop"},
				{regex: /\w+$/um, token: "variable-2", transition: "#pop"},
				{regex: /\w+/um, token: "variable-2"},
				{regex: /[\(\)]$/um, token: "punctuation", transition: "#pop"},
				{regex: /[\(\)]/um, token: "punctuation"},
				{regex: /([ \t]+)/um, token: "whitespace"},
		],
	});
}