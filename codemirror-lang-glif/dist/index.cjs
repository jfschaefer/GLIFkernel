'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lr = require('@lezer/lr');
var language = require('@codemirror/language');
var highlight = require('@lezer/highlight');
var common = require('@lezer/common');

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier$3 = {__proto__:null,import:40, i:40, archive:40, a:40, status:40, s:40, construct:40, c:40, populate:40, elpigen:40, eg:40, filter:40, help:40, h:40, query:40, apply:40, parse:40, p:40, put_string:40, ps:40, put_tree:40, pt:40, linearize:40, l:40, visualize_tree:40, vt:40, visualize_parse:40, vp:40, generate_random:40, gr:40, generate_trees:40, gt:40};
const parser$4 = lr.LRParser.deserialize({
  version: 14,
  states: "$[QYQPOOOOQO'#Ca'#CaO_QPO'#C`OsQPO'#C_OOQO'#Ch'#ChQYQPOOO!OQPO'#CbOOQO'#Cf'#CfOOQO'#Cr'#CrO!TQPO'#CqOOQO'#Ci'#CiO!}QPO,58zOOQO'#Cj'#CjO!lQPO,58zOYQPO'#CkO#UQPO,58yOOQO-E6f-E6fOOQO,58|,58|O#aQPO,59]OOQO-E6g-E6gO#iQPO1G.fOOQO-E6h-E6hOOQO,59V,59VOOQO-E6i-E6iOOQO1G.w1G.w",
  stateData: "#}~ObOSPOS~OdPO~OVUOXWOcVOZSX`SXdSX~OZ^O`RXdRX~OcaO~OWbOVeXXeXZeX`eXceXdeX~OXWOcVOZSa`SadSa~OVUO~P!lOZ^O`RadRa~OXWOcVO~OXWOcVOZSi`SidSi~OPV~",
  goto: "#OgPPPhlsxPPP|P!T!Z!a!kPPPPP!q!uTSOTSROTRf^VQOT^TXQZZWQZ]bdQTOR`TQZQRcZQ]QQdZTe]dQ_RRg_TYQZW[QZ]dRhb",
  nodeNames: "⚠ LineComment Program Command Single_command CommandName ArgName - = String Keywordval Pipe",
  maxTerm: 22,
  skippedNodes: [0,1],
  repeatNodeCount: 4,
  tokenData: "%]~R^XY}YZ}]^}pq}rs!`st#|uv#|}!O$e!Q![$m!_!`%R!c!}$m#R#S$m#T#o$m#p#q%W~!SSb~XY}YZ}]^}pq}~!cVOr!`rs!xs#O!`#O#P!}#P;'S!`;'S;=`#v<%lO!`~!}OX~~#QRO;'S!`;'S;=`#Z;=`O!`~#^WOr!`rs!xs#O!`#O#P!}#P;'S!`;'S;=`#v;=`<%l!`<%lO!`~#yP;=`<%l!`~$RSP~OY#|Z;'S#|;'S;=`$_<%lO#|~$bP;=`<%l#|~$jPV~}!O#|~$rTc~}!O$m!Q![$m!c!}$m#R#S$m#T#o$m~%WOW~~%]OZ~",
  tokenizers: [0],
  topRules: {"Program":[0,2]},
  specialized: [{term: 19, get: (value) => spec_identifier$3[value] || -1}],
  tokenPrec: 134
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier$2 = {__proto__:null,gf:48, apply:56, archive:56, a:56, construct:56, c:56, elpigen:56, eg:56, filter:56, generate_random:56, gr:56, generate_trees:56, gt:56, help:56, h:56, import:56, i:56, linearize:56, l:56, parse:56, p:56, populate:56, put_string:56, ps:56, put_tree:56, pt:56, query:56, status:56, s:56, visualize_parse:56, vp:56, visualize_tree:56, vt:56, abstract:58, concrete:58, incomplete:58, resource:58, interface:58, instance:58, theory:60, view:60, mmt:62, elpi:64, "elpi-notc":64, script:68};
const parser$3 = lr.LRParser.deserialize({
  version: 14,
  states: "'tO]QPOOO!cQPO'#C`OOQO'#C`'#C`OOQO'#Cd'#CdO!jQPO'#CdO!qQPO'#ChOOQO'#Ch'#ChO!xQPO'#ClQOQPOOO#PQPO'#CaO#UQPO'#CcO#]QPO'#CeO#dQPO'#CfO#iQPO'#CiO#nQPO'#CkO#uQPO'#CmOOQO'#Cv'#CvOOQO'#Co'#CoO#zQPO'#CbOOQO'#Cb'#CbOOQO,58z,58zO$RQPO'#CgOOQO'#Cg'#CgOOQO,59O,59OO$YQPO'#CjOOQO'#Cj'#CjOOQO,59S,59SO$aQPO'#CnOOQO'#Cn'#CnOOQO,59W,59WO$hQPO,58{O$mQPO,58}OOQO,58},58}O$tQPO,59POOQO,59P,59PO${QPO,59QO%QQPO,59TO%VQPO,59VOOQO,59V,59VO%^QPO,59XOOQO-E6m-E6mOOQO,58|,58|OOQO,59R,59ROOQO,59U,59UOOQO,59Y,59YOOQO1G.g1G.gOOQO1G.i1G.iOOQO1G.k1G.kOOQO1G.l1G.lOOQO1G.o1G.oOOQO1G.q1G.qOOQO1G.s1G.s",
  stateData: "%h~OfOSPOSQOS~OhXOlZOmYOn^Oo]Op_Or[O~Og`Oh`Oi`Ok`Ol`Om`On`Oo`Op`O~OqcO~PtOqfO~PtOqiO~PtOqlO~PtOinO~OqpO~PtOqrO~PtOisO~OitO~OqvO~PtOiwO~OqyO~PtOqzO~PtOq{O~PtOq|O~PtOg}O~Oq!OO~PtOq!PO~PtOg!QO~Og!RO~Oq!SO~PtOg!TO~OPQgk~",
  goto: "#bkPPPPlorulx{!Ol!R!U!Xl![!_!bPPPPPP#QRWORPORdPRQORRORSORgSRTORjTRUORVORmVQbPQeSQhTQkVQoYQqZQu^_xbehkoqumaPSTVYZ^behkoqu",
  nodeNames: "⚠ LineComment BlockComment Cell GfCell GfHeader UnmatchedGfContent MatchedGfContent ScriptCell MatchedScriptContent ScriptHeader UnmatchedScriptContent MmtCell MmtHeader UnmatchedMmtContent MatchedMmtContent ElpiCell ElpiHeader UnmatchedElpiContent",
  maxTerm: 34,
  skippedNodes: [0,1,2],
  repeatNodeCount: 1,
  tokenData: "(r~RlOX!yXY#OYZ#OZ]!y]^#O^p!ypq#Oqs!yst#atu!yuv#av}!y}!O$]!O!P%z!P!Q&c!Q![%z![!](b!]!c!y!c!}%z!}#R!y#R#S%z#S#T!y#T#o%z#o;'S!y;'S;=`(g<%l~!y~O!y~~(m~#OOk~~#TSf~XY#OYZ#O]^#Opq#O~#hSP~k~OY#tZ;'S#t;'S;=`$V<%lO#t~#ySP~OY#tZ;'S#t;'S;=`$V<%lO#t~$YP;=`<%l#t~$bUg~}!O$t!O!P%z!Q![%z!c!}%z#R#S%z#T#o%z~${_P~g~OY#tZ}#t}!O$t!O!P$t!P!Q#t!Q![$t![!c#t!c!}$t!}#R#t#R#S$t#S#T#t#T#o$t#o;'S#t;'S;=`$V<%lO#t~&PUg~}!O%z!O!P%z!Q![%z!c!}%z#R#S%z#T#o%z~&hQk~z{&n!P!Q'o~&qTOz&nz{'Q{;'S&n;'S;=`'i<%lO&n~'TTO!P&n!P!Q'd!Q;'S&n;'S;=`'i<%lO&n~'iOQ~~'lP;=`<%l&n~'rSO%C|(O%DP;'S(O;'S;=`([<%lO(O~(RR%C|%C}'d%C}%DO'd%DO%DP'd~(_P;=`<%l(O~(gOi~~(jP;=`<%l!y~(rOq~",
  tokenizers: [0],
  topRules: {"Cell":[0,3]},
  specialized: [{term: 23, get: (value) => spec_identifier$2[value] || -1}],
  tokenPrec: 203
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier$1 = {__proto__:null,incomplete:10, abstract:148, resource:148, interface:148, concrete:148, instance:148, of:16, with:32, open:38, in:40, cat:50, lin:50, def:50, lindef:50, oper:50, fun:50, data:50, flags:50, param:50, lincat:50, Type:66, Ptype:66, Str:66, Strs:66, table:80, _:160, variants:98, case:102, pre:104, let:118};
const parser$2 = lr.LRParser.deserialize({
  version: 14,
  states: "8lO`QPOOOOQO'#Cb'#CbOhQPOOOcQPOOOOQO'#Cc'#CcOmQPOOOuQPOOO!TQPOOO!YQPO'#DyO!kQPO'#CfQ!pQPOOO!uQPO'#CfOpQPOOO#QQPO'#DjO#VQPO,5:eO#tQPO,59QO$VQPO,59QO$[QPO,59QOOQO,59Q,59QO$dQPO'#CsQOQPOOOOQO'#Dz'#DzO$lQPO'#DzO$qQPO,59QOOQO,5:U,5:UOOQO-E7h-E7hOOQO1G.l1G.lO$yQPO1G.lO%XQPO'#DyO%sQPO1G.lO%xQPO1G.lO$VQPO1G.lOOQO'#Dl'#DlO&ZQPO,59_OOQO,59_,59_O$VQPO'#CtO&cQPO,5:fO&kQPO'#DkO&sQPO1G.lO&{QPO7+$WOOQO7+$W7+$WO'ZQPO7+$WO&{QPO7+$WO'`QPO7+$WOOQO-E7j-E7jOOQO1G.y1G.yO'eQPO'#CvO'yQPO'#DmO(OQPO,59`OOQO1G0Q1G0QO(ZQPO1G0QOOQO,5:V,5:VOOQO-E7i-E7iOOQO<<Gr<<GrO(`QPO<<GrO(qQPO<<GrO)PQPO<<GrOOQO'#Dn'#DnO)UQPO,59bO)jQPO,59bO)jQPO,59bOOQO,5:X,5:XOOQO-E7k-E7kO*kQPO7+%lOOQOAN=^AN=^O*pQPOAN=^O+OQPOAN=^OOQO-E7l-E7lO)jQPO1G.|O)jQPO1G.|OOQO'#Cz'#CzOOQO'#Cy'#CyO)jQPO'#DQO$VQPO'#DRO)jQPO'#DTOOQO'#DP'#DPOOQO'#Cx'#CxO+aQPO1G.|O,ZQPO'#CxO,lQPO'#CxO,qQPO'#CxO)jQPO'#CxO,vQPO'#CxO,{QPO'#CxO-TQPO1G.|OOQO<<IW<<IWO.QQPOG22xOOQOG22xG22xO.QQPOG22xO.`QPO7+$hO/YQPO7+$hO0VQPO,59lO0|QPO'#DSO1XQPO,59mO1^QPO,59oO2WQPO,59dO)jQPO,59dO3dQPO,59dOOQO'#DY'#DYO3lQPO,59dO3wQPO,59dO4VQPO'#DVOOQO,59d,59dO4kQPO'#D`O4rQPO,59dO5fQPO,59dO5nQPO,59dO)jQPO7+$hOOQOLD(dLD(dO5sQPOLD(dO)jQPO<<HSOOQO1G/W1G/WO)jQPO1G/WO$VQPO'#DoO6RQPO,59nOOQO1G/X1G/XO)jQPO'#DpO6^QPO1G/ZOOQO1G/Z1G/ZO)jQPO1G/ZO6iQPO1G/OOOQO1G/O1G/OO7uQPO1G/OO7zQPO'#DsO8SQPO1G/OO)jQPO1G/OO8SQPO1G/OOOQO'#DX'#DXO4VQPO'#DZOOQO'#DW'#DWO8_QPO,59qOOQO,59z,59zO8mQPO,59zO,lQPO1G/OO9dQPO1G/OO9iQPO1G/OO9nQPO<<HSOOQO!$'LO!$'LOO:hQPOAN=nO;bQPO7+$rOOQO,5:Z,5:ZOOQO-E7m-E7mO<UQPO,5:[OOQO-E7n-E7nOOQO7+$u7+$uO)jQPO7+$uO=OQPO7+$uOOQO7+$j7+$jOOQO,5:_,5:_OOQO-E7q-E7qO)jQPO7+$jO=rQPO7+$jO?OQPO7+$jO?ZQPO,59uO4VQPO,59rO)jQPO1G/]O)jQPO'#DrO?iQPO1G/fOOQO1G/f1G/fO?qQPO7+$jOOQO<<H^<<H^O?vQPO<<HaOOQO<<Ha<<HaO@jQPO<<HUO)jQPO<<HUOOQO1G/a1G/aOAvQPO1G/^OBXQPO7+$wOCOQPO,5:^OOQO-E7p-E7pOOQO7+%Q7+%QOOQOAN={AN={OCuQPOAN=pO4VQPO'#DqOERQPO<<HcOOQO<<Hc<<HcOEZQPO,5:]OOQO-E7o-E7oOOQOAN=}AN=}O)jQPO1G/wOEiQPO7+%c",
  stateData: "Fm~O!jOSPOSQOSROS~OTRO!lPO~O!kSO~OWVOXUO~OcZO!kWOfYP!hYP~O!k[O~OZ]O]aO^`O`_O[!mX~O[bO~OfcO~OafOdbO!keO~O!khO~OZ]O[!ma_!maX!mak!ma!k!ma!o!mae!mad!ma~O[jOafO!keOfYa!hYa~O!klO~O^oO`nO~OerOisO~O!ktO~OZuOdjO~OZuO[xOfYi!hYi~OZ]O_!mXX!mXk!mX!k!mX!o!mXe!mXd!mX~O_yO~O[xOafO!keOfYi!hYi~Oe}OisO~OX!SOb!RO~OafO!keO~OZuOdxO~OZuO[!VOfYq!hYq~O`!WO~O_!YO~OX!]Ok!^O!k!ZO!ojXejXdjX~O!o!_O~O!klOehaiha~O!k!aO~O[!bOafO!keOfYy!hYy~OZuO[!bOfYy!hYy~O`!dO~OX!fOk!gO!k!ZO!ojaejadja~Oa!jOf!kOi!tOo!hOp!hOq!iOr!iOx!qO!R!rO!T!sO!U!qO![!pO!]!uO!k!iO!q!lO~Ob!wO~OZuO[!yOfY!R!hY!R~O[!yOafO!keOfY!R!hY!R~O[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!ojiejidji~P)jO!Q#SO!X#SO![#WO!k#VO!r#UO~Of#XO~Of#ZO~O!k#SO~Of#]O!klO~OX#_O[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!ojiejidji~P)jOZuO[#`OfY!Z!hY!Z~O[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!ojqejqdjq~P)jOX#bO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!ojqejqdjq~P)jO[#SOb#cOk#dO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO~P)jO!o#eOevXdvX~Oe#gO~OZ#hO[#SOk#kO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!p#jO!t#SO~P)jO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!olaXlablaklaZla!plaWlaeladla~P)jO!Z#nO!k#mO~OZ#oO!Q#qO!X#qO~O!Q#qO!X#qO!k#rO!r#UO~Oa#tOo!hOp!hOr#sO!k#sO!r#UO~Oe#wO~P)jOW#yO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO~P)jOe#zO!klO~Od#qO~OZuO[#}OfY!c!hY!c~O!o#eOevadva~OZ#hOk$VO!p$UO~O[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!oliXliblikliZli!pliWlielidli~P)jOp$XO~O!k$YO!r#UO~OZ#oO!Q$[O!X$[O~O!O$`O!P$`O!Q$aO!s$`O~O[#SOe$dO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!o$bO!t#SO~P)jOd$[O~Oe$eO~O[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!ojyejydjy~P)jO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!oj!Rej!Rdj!R~P)jO[#SOb$fO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO~P)jO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SOZ!dak!da!p!da~P)jO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!p$hO!t#SO~P)jO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!olqXlqblqklqZlq!plqWlqelqdlq~P)jOZ#oO!Q$jO!X$jO~Ob$kO!O$`O!P$`O!s$`O~Oe$pO!o$bO~Od$jO~O[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!p$qO!t#SO~P)jO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!olyXlyblyklyZly!plyWlyelydly~P)jO!O$`O!P$`O!s$`O!Qzibzi~O[#SOe$uO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!o$sO!t#SO~P)jO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SOe!fa!o!fa~P)jO[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SO!ol!RXl!Rbl!Rkl!RZl!R!pl!RWl!Rel!Rdl!R~P)jOe$xO!o$sO~O!O$`O!P$`O!Q$yO!s$`O~O[#SO!O#SO!P#SO!Q#SO!V#SO!W#SO!X#SO!Y#TO!t#SOe!eq!o!eq~P)jORP[!W!V!X!O!QXQ]f~",
  goto: "+z!oPPPPPP!p!tPP!wPPPPPPPPPPPP!z!}P#RP#_%Y&XPPPP%Y'^'^(]'^P(f(l(x)O(xPPPP)_PPPPPPPPP)b)i*P*V*]*c*i*o*u*{PPPPP+V+hTQORRTQRYURdYTpcqS!Ps!QU#O!k!u#]R$Q#eQ!o!]Q!v!^Q!{!fQ!|!gQ!}!jQ#Q!l|#R!o!v!{!|!}#Q#R#[#l#x#|$O$P$S$W$]$g$i$m$n$r$zQ#[!sQ#l#SQ#x#ZQ#|#_Q$O#bQ$P#dQ$S#hQ$W#kQ$]#qQ$g$VQ$i$[Q$m$aQ$n$bQ$r$jR$z$y!y!n!]!^!f!g!j!l!o!s!v!{!|!}#Q#R#S#Z#[#_#b#d#h#k#l#q#x#|$O$P$S$V$W$[$]$a$b$g$i$j$m$n$r$y$z!x!i!]!^!f!g!j!l!o!s!v!{!|!}#Q#R#S#Z#[#_#b#d#h#k#l#q#x#|$O$P$S$V$W$[$]$a$b$g$i$j$m$n$r$y$zX#s#X#t$`$s!y!m!]!^!f!g!j!l!o!s!v!{!|!}#Q#R#S#Z#[#_#b#d#h#k#l#q#x#|$O$P$S$V$W$[$]$a$b$g$i$j$m$n$r$y$zQ#P!kQ#^!uR#{#]Q#Y!qR$X#yQ#v#XQ$_#tQ$l$`R$v$sX#u#X#t$`$sQ#V!pQ#r#WW#s#X#t$`$sR$Y#oR#Y!rS^WlRi^QvgQwkY!Uvw!X!x#aQ!XzQ!x!cR#a!zQqcR|qQ!QsR!`!QQ![!OR!e![Q#f#OR$R#fQ#i#QR$T#iQ$t$mR$w$tQ$c#xR$o$cQ#p#VS$Z#p$^R$^#rQXUQm`Q{o]!Os!Q!k!u#]#eQgZQk_QznQ!TuQ!c!WR!z!d",
  nodeNames: "⚠ LineComment BlockComment Pragma Grammar GrammarModifier GrammarType GrammarName KeyWord = PreModBody , ** - [ ] KeyWord ( ) KeyWord KeyWord } { MainModBody Section KeyWord Decl : Expr AtomicExpr Literal String Integer Sort ? BracketedExpr ParenExpr RecordExpr DeclsIn TupleExpr KeyWord CaseBody Pattern AtomicPattern Underscore BracketedPattern + | => KeyWord VariantsBody KeyWord KeyWord ++ * -> . $ \\ KeyWord",
  maxTerm: 82,
  nodeProps: [
    ["closedBy", 17,")",22,"}"],
    ["openedBy", 18,"(",21,"{"]
  ],
  skippedNodes: [0,1,2,3],
  repeatNodeCount: 10,
  tokenData: ",W~RoXY#SYZ#S]^#Spq#Sqr#ers#jtu%Wxy%]yz%bz{%g{|%t|}&R}!O&W!O!P(R!Q![(W![!](`!]!^(e!^!_(j!_!`(o!`!a(|!a!b)R!b!c)W!c!})]!}#O)n#O#P)s#P#Q)x#R#S)]#T#o)]#o#p)}#p#q+|#q#r,R~#XS!j~XY#SYZ#S]^#Spq#S~#jO!t~~#mVOr#jrs$Ss#O#j#O#P$X#P;'S#j;'S;=`%Q<%lO#j~$XOo~~$[RO;'S#j;'S;=`$e;=`O#j~$hWOr#jrs$Ss#O#j#O#P$X#P;'S#j;'S;=`%Q;=`<%l#j<%lO#j~%TP;=`<%l#j~%]O!Z~~%bOa~~%gOb~~%lP!W~z{%o~%tO[~~%yP!O~{|%|~&RO!V~~&WOZ~~&]Q]~}!O&c!`!a'|~&hUP~OY&zZs&zst'ct;'S&z;'S;=`']<%lO&z~'PSP~OY&zZ;'S&z;'S;=`']<%lO&z~'`P;=`<%l&z~'jSR~P~OY'cZ;'S'c;'S;=`'v<%lO'c~'yP;=`<%l'c~(RO!X~~(WO!Y~~(]Pp~!Q![(W~(eOk~~(jO!o~~(oO!q~~(tPX~!`!a(w~(|O!Q~~)RO!p~~)WOr~~)]O!s~~)bS!k~!Q![)]!c!})]#R#S)]#T#o)]~)sO^~~)xO![~~)}O_~~*SPf~}!O*V~*YTO}*V}!O*i!O;'S*V;'S;=`+a<%lO*V~*lTO#q*V#q#r*{#r;'S*V;'S;=`+g;=`O*V~+QTQ~O}*V}!O*i!O;'S*V;'S;=`+a<%lO*V~+dP;=`<%l*V~+jUO}*V}!O*i!O;'S*V;'S;=`+a;=`<%l*V<%lO*V~,RO!P~~,WOe~",
  tokenizers: [0],
  topRules: {"Grammar":[0,4]},
  specialized: [{term: 73, get: (value) => spec_identifier$1[value] || -1}],
  tokenPrec: 1718
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,"//":68, "/T":68, theory:12, ":":70, "=":72, view:18, "->":74, "#":76, role:38, include:44, namespace:50, fixmeta:50};
const parser$1 = lr.LRParser.deserialize({
  version: 14,
  states: "(|QVQPOOOeQPO'#C`OOQO'#Cv'#CvQVQPOOOsQPO'#C_O{QPO'#CaO{QPO'#CaO!QQPO'#CtOOQO'#Ci'#CiO!VQPO'#ChOOQO'#Cf'#CfOOQO'#Cx'#CxO!hQPO,58zOOQO,58z,58zO!QQPO'#CqO!vQPO'#CsOOQO-E6t-E6tOOQO'#Cw'#CwO#OQPO,58yOOQO,58y,58yOOQO'#Cc'#CcO#WQPO,58{O#`QPO,58{OOQO'#Cd'#CdO#eQPO,59`OOQO'#Cj'#CjOOQO,59S,59SO#jQPO,59SOvQPO'#CkOvQPO'#ClOvQPO'#CmOvQPO'#CnOOQO-E6v-E6vOOQO1G.f1G.fO#rQPO,59]O#wQPO,59_OOQO,59_,59_OOQO-E6u-E6uOOQO1G.e1G.eOOQO1G.g1G.gO!QQPO1G.gO!QQPO1G.gOOQO1G.z1G.zO!YQPO'#CyO$PQPO1G.nOOQO1G.n1G.nO$XQPO,59VO$dQPO,59WO$oQPO,59XO$zQPO,59YOOQO1G.w1G.wOOQO1G.y1G.yO%VQPO7+$RO%[QPO7+$ROOQO,59e,59eOOQO-E6w-E6wOOQO7+$Y7+$YOOQO<<Gm<<GmO!QQPO<<GmO%aQPOAN=XOOQOG22sG22s",
  stateData: "%f~OpOS~OUTOXUOiVOrSO~OQ]Of^OqWOr_O~OQcOqaO~OqdO~OqgO~OZjOcoOslOtmOvnO~OQqOf^OqWOr_O~OZtOqaO~OQvOqaO~OsxOtwO~OsyO~OQzO~OZ}Od{O~OZ!SO~OZ!TOqaO~OZ!YOd{O~OqaOZ_ad_a~OqaOZ`ad`a~OqaOZaadaa~OqaOZbadba~Ot!ZO~Ou![O~Ot!^O~O",
  goto: "#rnPPPoosPw}P!^P!b!f!j!p!p!p!pPP!bP!^oP!t!z#f#lTQORTPORQeTRfUQhVQr^Q!UxQ!VyR!]![TZP[TYP[TXP[QkXR!W{TiX{QROR`RQbSQs_[ubs!O!P!Q!RQ!OlQ!PmQ!QnR!RoQ[PRp[Q|kR!X|",
  nodeNames: "⚠ Document MD ModuleComment Module ModuleHeader KeyWord ModuleName ModuleRef KeyWord Declaration DD StandardDeclaration NewIdentifier Object TypeObject DefiniensObject NotationObject RoleObject KeyWord OD IncludeDeclaration KeyWord DeclarationComment DirectiveStmt KeyWord",
  maxTerm: 38,
  skippedNodes: [0],
  repeatNodeCount: 4,
  tokenData: "#a~R^OX}XY!oYZ!oZ]}]^!o^p}pq!oq%C|}%C|%C}#Q%C}%DO#V%DO%DP#[%DP;'S};'S;=`!i<%lO}~!SVq~OX}Z]}^p}q%C|}%DP;'S};'S;=`!i<%lO}~!lP;=`<%l}~!tSp~XY!oYZ!o]^!opq!o~#VOd~~#[OZ~~#aOQ~",
  tokenizers: [0],
  topRules: {"Document":[0,1]},
  specialized: [{term: 33, get: (value) => spec_identifier[value] || -1}],
  tokenPrec: 0
});

// place-holder, will be replaced with correct function in index.ts
// (I doubt that this is the correct way, but it works :D )
const specialize_elpi_ident = () => -1;

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = lr.LRParser.deserialize({
  version: 14,
  states: "#fQ]QPOOOOQO'#Cd'#CdOcQPO'#CqOcQPO'#CsOhQPO'#CtOOQO'#Cc'#CcOOQO'#Ck'#CkQ]QPOOOhQPO,59]O!SQPO,59_OOQO'#Cl'#ClO!XQPO'#CrO!sQPO,59`OOQO-E6i-E6iO!xQPO1G.wOOQO1G.y1G.yOOQO-E6j-E6jOOQO1G.z1G.zOOQO7+$c7+$c",
  stateData: "!}~OdOSSOSTOS~OPQOQRObPO~ORYOXYOYYOZYO[YO]YObYO^fP~O^_O~ORYOXYOYYOZYO[YO]YObYO^fX~O^aO~O^bO~O",
  goto: "!aiPPPPPPPjnPPPPPPx!OPPPP!V!Z!V!VTUOVSSOVQWQRXRQVOR]VSZSWR`ZTTOVQ[SR^W",
  nodeNames: "⚠ TypingPred ModulePred ElpiKeyword LineComment BlockComment Program Rule HeadHead Variable Discard_variable String Int Operator Period",
  maxTerm: 25,
  skippedNodes: [0,4,5],
  repeatNodeCount: 2,
  tokenData: "'d~R_XY!QYZ!Q]^!Qpq!Qrs!cuv$P}!O$h!O!P$s!P!Q$x!Q![&P!_!`$n!c!}&X#O#P$n#R#S&j#T#o'R~!VSd~XY!QYZ!Q]^!Qpq!Q~!fVOr!crs!{s#O!c#O#P#Q#P;'S!c;'S;=`#y<%lO!c~#QOZ~~#TRO;'S!c;'S;=`#^;=`O!c~#aWOr!crs!{s#O!c#O#P#Q#P;'S!c;'S;=`#y;=`<%l!c<%lO!c~#|P;=`<%l!c~$USS~OY$PZ;'S$P;'S;=`$b<%lO$P~$eP;=`<%l$P~$kP!`!a$n~$sO]~~$xO^~~${Pz{%O~%RTOz%Oz{%b{;'S%O;'S;=`%y<%lO%O~%eTO!P%O!P!Q%t!Q;'S%O;'S;=`%y<%lO%O~%yOT~~%|P;=`<%l%O~&UP[~!Q![&P~&^SX~!Q![&X!c!}&X#R#S&X#T#o&X~&mP!c!}&p~&uSY~!Q![&p!c!}&p#R#S&p#T#o&p~'WSi~!Q!['R!c!}'R#R#S'R#T#o'R",
  tokenizers: [0],
  topRules: {"Program":[0,6]},
  specialized: [{term: 25, get: (value, stack) => (specialize_elpi_ident() << 1), external: specialize_elpi_ident}],
  tokenPrec: 0
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const TypingPred = 1,
  ModulePred = 2,
  ElpiKeyword = 3,
  other_token = 18;

// GLIF SCRIPT
const GLIFScriptLanguage = language.LRLanguage.define({
    parser: parser$4.configure({
        props: [
            language.indentNodeProp.add({
                Command: language.continuedIndent(),
                SingleCommand: language.continuedIndent(),
            }),
            highlight.styleTags({
                CommandName: highlight.tags.keyword,
                String: highlight.tags.string,
                LineComment: highlight.tags.lineComment,
                // Pipe: t.controlOperator,
                ArgName: highlight.tags.propertyName,
                // Keywordval: t.labelName,
            })
        ]
    }),
    languageData: {
        commentTokens: { line: "#" }
    }
});
function GLIFScript() {
    return new language.LanguageSupport(GLIFScriptLanguage);
}
// GF
const GFLanguage = language.LRLanguage.define({
    parser: parser$2.configure({
        props: [
            language.indentNodeProp.add({
                Section: language.continuedIndent(),
                MainModBody: language.delimitedIndent({ closing: "}" }),
                BlockComment: language.delimitedIndent({ closing: "-}" }),
                BracketedPattern: language.delimitedIndent({ closing: ")" }),
                ParenExpr: language.delimitedIndent({ closing: ")" }),
                RecordExpr: language.delimitedIndent({ closing: "}" }),
                TupleExpr: language.delimitedIndent({ closing: ">" }),
            }),
            highlight.styleTags({
                String: highlight.tags.string,
                LineComment: highlight.tags.lineComment,
                KeyWord: highlight.tags.keyword,
                GrammarModifier: highlight.tags.keyword,
                GrammarType: highlight.tags.keyword,
                GrammarName: highlight.tags.className,
                Pragma: highlight.tags.special(highlight.tags.lineComment),
                BlockComment: highlight.tags.blockComment,
            })
        ]
    }),
    languageData: {
        commentTokens: { line: "--" }
    }
});
function GF() {
    return new language.LanguageSupport(GFLanguage);
}
// MMT
const MMTLanguage = language.LRLanguage.define({
    parser: parser$1.configure({
        props: [
            language.indentNodeProp.add({
                Module: language.delimitedIndent({ closing: "❚" }),
                Declaration: language.delimitedIndent({ closing: "❙" }),
                Object: language.delimitedIndent({ closing: "❘" }),
                DeclarationComment: language.delimitedIndent({ closing: "❙" }),
                ModuleComment: language.delimitedIndent({ closing: "❚" }),
            }),
            highlight.styleTags({
                KeyWord: highlight.tags.keyword,
                ModuleComment: highlight.tags.blockComment,
                DeclarationComment: highlight.tags.blockComment,
                ModuleName: highlight.tags.definition(highlight.tags.className),
                NotationObject: highlight.tags.regexp,
                TypeObject: highlight.tags.typeName,
                ModuleRef: highlight.tags.name,
                OD: highlight.tags.punctuation,
                DD: highlight.tags.punctuation,
                MD: highlight.tags.punctuation,
            })
        ]
    })
});
function MMT() {
    return new language.LanguageSupport(MMTLanguage);
}
// ELPI
const ELPILanguage = language.LRLanguage.define({
    parser: parser.configure({
        props: [
            language.indentNodeProp.add({
                Rule: language.delimitedIndent({ closing: ".", align: false }),
            }),
            highlight.styleTags({
                LineComment: highlight.tags.lineComment,
                BlockComment: highlight.tags.blockComment,
                String: highlight.tags.string,
                Int: highlight.tags.integer,
                TypingPred: highlight.tags.keyword,
                ModulePred: highlight.tags.keyword,
                Variable: highlight.tags.propertyName,
                Discard_variable: highlight.tags.propertyName,
            })
        ],
        specializers: [{
                from: specialize_elpi_ident,
                to: value => {
                    if (value == "kind" || value == "type" || value == "pred") {
                        return TypingPred;
                    }
                    if (value == "accumulate") {
                        return ModulePred;
                    }
                    if (value == "pi") {
                        return ElpiKeyword;
                    }
                    return other_token;
                }
            }]
    })
});
function ELPI() {
    return new language.LanguageSupport(ELPILanguage);
}
// GLIF CELL
const GLIFCellLanguage = language.LRLanguage.define({
    parser: parser$3.configure({
        props: [
            highlight.styleTags({
                ElpiHeader: highlight.tags.documentMeta,
                MmtHeader: highlight.tags.documentMeta,
                ScriptHeader: highlight.tags.documentMeta,
                GfHeader: highlight.tags.documentMeta,
                LineComment: highlight.tags.lineComment,
                BlockComment: highlight.tags.blockComment,
            })
        ],
        wrap: common.parseMixed(node => {
            if (node.name == "MatchedGfContent" || node.name == "UnmatchedGfContent") {
                // console.log("GF CONTENT");
                return { parser: GFLanguage.parser };
            }
            if (node.name == "MatchedMmtContent" || node.name == "UnmatchedMmtContent") {
                // console.log("MMT CONTENT");
                return { parser: MMTLanguage.parser };
            }
            if (node.name == "MatchedElpiContent" || node.name == "UnmatchedElpiContent") {
                // console.log("ELPI CONTENT");
                return { parser: ELPILanguage.parser };
            }
            if (node.name == "MatchedScriptContent" || node.name == "UnmatchedScriptContent") {
                // console.log("SCRIPT CONTENT");
                return { parser: GLIFScriptLanguage.parser };
            }
            return null;
        }),
    })
});
function GLIFCell() {
    return new language.LanguageSupport(GLIFCellLanguage);
}

exports.ELPI = ELPI;
exports.ELPILanguage = ELPILanguage;
exports.GF = GF;
exports.GFLanguage = GFLanguage;
exports.GLIFCell = GLIFCell;
exports.GLIFCellLanguage = GLIFCellLanguage;
exports.GLIFScript = GLIFScript;
exports.GLIFScriptLanguage = GLIFScriptLanguage;
exports.MMT = MMT;
exports.MMTLanguage = MMTLanguage;
